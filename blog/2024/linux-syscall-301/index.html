<!DOCTYPE html> <html lang="en"> <head> <meta http-equiv="Content-Type" content="text/html; charset=UTF-8"> <meta charset="utf-8"> <meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no"> <meta http-equiv="X-UA-Compatible" content="IE=edge"> <title> Syscall 301: A Deep Dive into the System Calls in Linux Kernel | Yihan Yang </title> <meta name="author" content="Yihan Yang"> <meta name="description" content="Highly detailed walkthrough of system call mechanism"> <meta name="keywords" content="jekyll, jekyll-theme, academic-website, portfolio-website"> <link rel="stylesheet" href="/assets/css/bootstrap.min.css?a4b3f509e79c54a512b890d73235ef04"> <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/css/mdb.min.css" integrity="sha256-jpjYvU3G3N6nrrBwXJoVEYI/0zw8htfFnhT9ljN3JJw=" crossorigin="anonymous"> <link defer rel="stylesheet" href="/assets/css/academicons.min.css?f0b7046b84e425c55f3463ac249818f5"> <link defer rel="stylesheet" type="text/css" href="https://fonts.googleapis.com/css?family=Roboto:300,400,500,700|Roboto+Slab:100,300,400,500,700|Material+Icons&amp;display=swap"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-github.css?591dab5a4e56573bf4ef7fd332894c99" media="" id="highlight_theme_light"> <link rel="shortcut icon" href="data:image/svg+xml,&lt;svg%20xmlns=%22http://www.w3.org/2000/svg%22%20viewBox=%220%200%20100%20100%22&gt;&lt;text%20y=%22.9em%22%20font-size=%2290%22&gt;%E2%9A%9B%EF%B8%8F&lt;/text&gt;&lt;/svg&gt;"> <link rel="stylesheet" href="/assets/css/main.css?d41d8cd98f00b204e9800998ecf8427e"> <link rel="canonical" href="https://yihan1998.github.io/blog/2024/linux-syscall-301/"> <link defer rel="stylesheet" href="/assets/css/jekyll-pygments-themes-native.css?5847e5ed4a4568527aa6cfab446049ca" media="none" id="highlight_theme_dark"> <script src="/assets/js/theme.js?0afe9f0ae161375728f7bcc5eb5b4ab4"></script> </head> <body class="fixed-top-nav "> <header> <nav id="navbar" class="navbar navbar-light navbar-expand-sm fixed-top" role="navigation"> <div class="container"> <a class="navbar-brand title font-weight-lighter" href="/"> <span class="font-weight-bold">Yihan</span> Yang </a> <button class="navbar-toggler collapsed ml-auto" type="button" data-toggle="collapse" data-target="#navbarNav" aria-controls="navbarNav" aria-expanded="false" aria-label="Toggle navigation"> <span class="sr-only">Toggle navigation</span> <span class="icon-bar top-bar"></span> <span class="icon-bar middle-bar"></span> <span class="icon-bar bottom-bar"></span> </button> <div class="collapse navbar-collapse text-right" id="navbarNav"> <ul class="navbar-nav ml-auto flex-nowrap"> <li class="nav-item "> <a class="nav-link" href="/">about </a> </li> <li class="nav-item "> <a class="nav-link" href="/blog/">blog </a> </li> <li class="nav-item "> <a class="nav-link" href="/publications/">publications </a> </li> <li class="nav-item "> <a class="nav-link" href="/projects/">projects </a> </li> <li class="nav-item "> <a class="nav-link" href="/repositories/">repositories </a> </li> <li class="nav-item "> <a class="nav-link" href="/cv/">cv </a> </li> <li class="nav-item "> <a class="nav-link" href="/teaching/">teaching </a> </li> <li class="nav-item "> <a class="nav-link" href="/people/">people </a> </li> <li class="nav-item dropdown "> <a class="nav-link dropdown-toggle" href="#" id="navbarDropdown" role="button" data-toggle="dropdown" aria-haspopup="true" aria-expanded="false">submenus </a> <div class="dropdown-menu dropdown-menu-right" aria-labelledby="navbarDropdown"> <a class="dropdown-item " href="/publications/">publications</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/projects/">projects</a> <div class="dropdown-divider"></div> <a class="dropdown-item " href="/blog/">blog</a> </div> </li> <li class="toggle-container"> <button id="light-toggle" title="Change theme"> <i class="fa-solid fa-moon"></i> <i class="fa-solid fa-sun"></i> </button> </li> </ul> </div> </div> </nav> <progress id="progress" value="0"> <div class="progress-container"> <span class="progress-bar"></span> </div> </progress> </header> <div class="container mt-5" role="main"> <div class="post"> <header class="post-header"> <h1 class="post-title">Syscall 301: A Deep Dive into the System Calls in Linux Kernel</h1> <p class="post-meta"> March 09, 2024 </p> <p class="post-tags"> <a href="/blog/2024"> <i class="fa-solid fa-calendar fa-sm"></i> 2024 </a>   ·   <a href="/blog/tag/linux"> <i class="fa-solid fa-hashtag fa-sm"></i> Linux</a>     ·   <a href="/blog/category/sample-posts"> <i class="fa-solid fa-tag fa-sm"></i> sample-posts</a>   </p> </header> <article class="post-content"> <div id="table-of-contents"> <ul id="toc" class="section-nav"> <li class="toc-entry toc-h1"> <a href="#set-up-the-syscall-table">Set up the syscall table</a> <ul> <li class="toc-entry toc-h2"><a href="#what-is-in-asmsyscalls_64h">What is in &lt;asm/syscalls_64.h&gt;?</a></li> <li class="toc-entry toc-h2"><a href="#why-does-archx86includegenerated-seem-weird">Why does /arch/x86/include/generated seem weird?</a></li> </ul> </li> <li class="toc-entry toc-h1"> <a href="#define-a-system-call-handler">Define a system call handler</a> <ul> <li class="toc-entry toc-h2"><a href="#how-is-a-syscall-hander-be-defined">How is a syscall hander be defined?</a></li> <li class="toc-entry toc-h2"> <a href="#how-to-deal-with-different-number-of-arguments">How to deal with different number of arguments?</a> <ul> <li class="toc-entry toc-h3"><a href="#extract-the-maximum-number-of-arguments-from-register-context">Extract the maximum number of arguments from register context</a></li> <li class="toc-entry toc-h3"><a href="#cast-the-register-content-into-the-required-type">Cast the register content into the required type</a></li> <li class="toc-entry toc-h3"><a href="#invocation-of-the-ultimate-syscall-handler">Invocation of the ultimate syscall handler</a></li> <li class="toc-entry toc-h3"><a href="#definition-of-argument-lists-via-__map">Definition of argument lists via __MAP</a></li> </ul> </li> </ul> </li> </ul> </div> <hr> <div id="markdown-content"> <p>In this artical, we are taking a deep dive into the system calls in Linux Kernel 5.4 on an <code class="language-plaintext highlighter-rouge">x86_64</code> architecture.</p> <h1 id="set-up-the-syscall-table">Set up the syscall table</h1> <p>The Linux Kernel utilizes a lot of tricks in C in an impressive way and the syscall table initilization is one of my favourite. It is a perfect example of how coding in C can be elegant, flexible, and creative.</p> <p>The definition of syscall table – also known as <code class="language-plaintext highlighter-rouge">sys_call_table</code> in the Linux Kernel – locates in <code class="language-plaintext highlighter-rouge">/arch/x86/entry/syscall_64.c</code> and is an array of function pointers. Below is the source code that performs syscall table setup:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);
#include</span> <span class="cpf">&lt;asm/syscalls_64.h&gt;</span><span class="cp">
#undef __SYSCALL_64
</span>
<span class="cp">#define __SYSCALL_64(nr, sym, qual) [nr] = sym,
</span>
<span class="n">asmlinkage</span> <span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">__NR_syscall_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_syscall_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__x64_sys_ni_syscall</span><span class="p">,</span>
<span class="cp">#include</span> <span class="cpf">&lt;asm/syscalls_64.h&gt;</span><span class="cp">
</span><span class="p">};</span>

<span class="cp">#undef __SYSCALL_64
</span></code></pre></div></div> <p>Remember we talked about the how unrealistic to manually initialize the syscall table in the previous artical? Here we are going to unveal the magic trick applied by the Linux Kernel, which is the use of <code class="language-plaintext highlighter-rouge">#define</code>, <code class="language-plaintext highlighter-rouge">#include</code>, and <code class="language-plaintext highlighter-rouge">#undef</code>.</p> <blockquote> <p>The first <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code> generates the declaration of every syscall handler.</p> <p>The second <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code> loads the address syscall handler into the <code class="language-plaintext highlighter-rouge">sys_call_table</code>, using their syscall number as the index within the syscall table array.</p> </blockquote> <p>Such a creative way of using the feature of C during the preprocessing phase! By defining, undefining, and redefining only one macro, the preprocessor could automatically generate all declaration of every syscall handler and the whole syscall table! How seemingless yet highly efficient it is!</p> <p>Now, if you are still curious about what is in this header, and how it is loaded when included, fasten your seat belt because we are going follow the preprocessor to see how miracle is performed. Allons-y!</p> <h2 id="what-is-in-asmsyscalls_64h">What is in <code class="language-plaintext highlighter-rouge">&lt;asm/syscalls_64.h&gt;</code>?</h2> <p>When I saw the above syscall initialization for the first time, I was shocked and confused: how and why does <code class="language-plaintext highlighter-rouge">&lt;asm/syscalls_64.h&gt;</code> get included here twice yet expanded into two different pieces of codes?</p> <p>To understand why, we need to look into the content of this header, which locates under <code class="language-plaintext highlighter-rouge">/arch/x86/include/generated/asm/syscalls_64.h</code>. Below is a clip of it:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__SYSCALL_64</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">__x64_sys_read</span><span class="p">,</span> <span class="p">)</span>
<span class="n">__SYSCALL_64</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">__x64_sys_write</span><span class="p">,</span> <span class="p">)</span>
<span class="n">__SYSCALL_64</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">__x64_sys_open</span><span class="p">,</span> <span class="p">)</span>
<span class="n">__SYSCALL_64</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">__x64_sys_close</span><span class="p">,</span> <span class="p">)</span>
<span class="p">...</span>
</code></pre></div></div> <p>For the sake of simplicity, I only show the what will be left after the preprocessing phase on the <code class="language-plaintext highlighter-rouge">x86_64</code> architecture. In the actual header, the Kernel uses other <code class="language-plaintext highlighter-rouge">#ifdef</code> directive to support more flexible Kernel configuration during preprocessing.</p> <p>To make things easier to understand, let’s take <code class="language-plaintext highlighter-rouge">read</code> for an example to see how the two different <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code> macros expand the above mappings separatedly.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define __SYSCALL_64(nr, sym, qual) extern asmlinkage long sym(const struct pt_regs *);
</span><span class="k">extern</span> <span class="n">asmlinkage</span> <span class="kt">long</span> <span class="nf">__x86_sys_read</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
<span class="p">...</span>
<span class="cp">#undef __SYSCALL_64
</span>
<span class="cp">#define __SYSCALL_64(nr, sym, qual) [nr] = sym,
</span>
<span class="n">asmlinkage</span> <span class="k">const</span> <span class="n">sys_call_ptr_t</span> <span class="n">sys_call_table</span><span class="p">[</span><span class="n">__NR_syscall_max</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
	<span class="p">[</span><span class="mi">0</span> <span class="p">...</span> <span class="n">__NR_syscall_max</span><span class="p">]</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">__x64_sys_ni_syscall</span><span class="p">,</span>
	<span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">__x86_sys_read</span><span class="p">,</span>
	<span class="p">...</span>
<span class="p">};</span>

<span class="cp">#undef __SYSCALL_64
</span></code></pre></div></div> <p>As shown above, the first <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code> expands the header into the declaration of syscall handlers, which will later be used to locate the handler entry during syscall table lookup. Notably, before expanding the second <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code>, the Kernel first initializes all syscall handler to be <code class="language-plaintext highlighter-rouge">__x64_sys_ni_syscall </code>, just in case any unsupported syscall number triggers a segmentation fault and blow up the whole Kernel. After this, the second <code class="language-plaintext highlighter-rouge">__SYSCALL_64</code> associates the syscall handler with its syscall number in the table. In this way, the Kernel implements a general setup of syscall table, independent from the varied syscall mapping on different hardware platforms.</p> <h2 id="why-does-archx86includegenerated-seem-weird">Why does <code class="language-plaintext highlighter-rouge">/arch/x86/include/generated</code> seem weird?</h2> <p>My first impression when I looked at this path is: how could someone name the folder to be <code class="language-plaintext highlighter-rouge">generated</code>? The answer may <em>not</em> surprise you: because this folder <strong>is</strong> generated! But how, why, and by whom?</p> <p>With a simple searching in the repository, we can easily locate the creator of the <code class="language-plaintext highlighter-rouge">generated/</code> folder — the <code class="language-plaintext highlighter-rouge">Makefile</code> under <code class="language-plaintext highlighter-rouge">/arch/x86/syscalls/</code>. Below is the part of it that is associated with the generation of syscall related files.</p> <div class="language-makefile highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nv">out</span> <span class="o">:=</span> <span class="nb">arch</span>/<span class="p">$(</span>SRCARCH<span class="p">)</span>/include/generated/asm

<span class="nv">syscall64</span> <span class="o">:=</span> <span class="p">$(</span>srctree<span class="p">)</span>/<span class="p">$(</span>src<span class="p">)</span>/syscall_64.tbl

<span class="nv">systbl</span> <span class="o">:=</span> <span class="p">$(</span>srctree<span class="p">)</span>/<span class="p">$(</span>src<span class="p">)</span>/syscalltbl.sh

<span class="nl">$(out)/syscalls_64.h</span><span class="o">:</span> <span class="nf">$(syscall64) $(systbl)</span>
	<span class="p">$(</span>call if_changed,systbl<span class="p">)</span>
</code></pre></div></div> <p>Basically, what it does is to call <code class="language-plaintext highlighter-rouge">syscalltbl.sh</code> that takes <code class="language-plaintext highlighter-rouge">syscall_64.tbl</code> as input and generates <code class="language-plaintext highlighter-rouge">syscalls_64.h</code>. How the bash script work is too detailed for this article, but in one sentence, it maps every single syscall number to its handler entry in a format of <code class="language-plaintext highlighter-rouge">__SYSCALL_64/X32(*index*, *handler_entry*)</code> in <code class="language-plaintext highlighter-rouge">syscalls_64.h</code>. The header file shall be regenerated if there is any changes in <code class="language-plaintext highlighter-rouge">syscalltbl.sh</code> or <code class="language-plaintext highlighter-rouge">syscall_64.tbl</code>. In fact, this is a universal approach for every hardware architecture that supports the Linux Kernel to automatically create the syscall header. If you look into the source code of version 5.4, there is some <code class="language-plaintext highlighter-rouge">Makefile</code> in each subfolder under <code class="language-plaintext highlighter-rouge">/arch/</code> that serves the same purpose like the commands above.</p> <p>Now let’s see how syscall numbers and syscall handler are mapped in <code class="language-plaintext highlighter-rouge">syscall_64.tbl</code>:</p> <div class="language-sh highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c"># The format is:</span>
<span class="c"># &lt;number&gt; &lt;abi&gt; &lt;name&gt; &lt;entry point&gt;</span>
<span class="c"># The abi is "common", "64", or "x32" for this file</span>
0	common	<span class="nb">read		</span>__x64_sys_read
1	common	write	__x64_sys_write
2	common	open		__x64_sys_open
3	common	close	__x64_sys_close
...
19	64		readv	__x64_sys_readv
20	64		writev	__x64_sys_writev
...
512	x32		readv	__x32_compat_sys_readv
513	x32		writev	__x32_compat_sys_writev
...
</code></pre></div></div> <p>It’s clear from the clip above that this file supports three types of ABI: <code class="language-plaintext highlighter-rouge">common</code> (for both 32-bit and 64-bit), <code class="language-plaintext highlighter-rouge">64</code> (for 64-bit), and <code class="language-plaintext highlighter-rouge">x32</code> (for 32-bit). You can also easily distinguish their type based on the prefix of the handler entry.</p> <h1 id="define-a-system-call-handler">Define a system call handler</h1> <p>If you try to search for the syscall handler we’ve mentioned above (e.g., <code class="language-plaintext highlighter-rouge">__x64_sys_read</code>), you might be confused when you fail to see any function with that name in the Kernel source code. Why and how could it be possible? The answer lies in another header file – <code class="language-plaintext highlighter-rouge">/include/linux/syscalls.h</code> – and we are about to be amazed by the wisdom of system designers again.</p> <h2 id="how-is-a-syscall-hander-be-defined">How is a syscall hander be defined?</h2> <p>Let’s take <code class="language-plaintext highlighter-rouge">read</code> as an exmaple again. The actual implementation locates in <code class="language-plaintext highlighter-rouge">/fs/read_write.c</code> and is defined as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">SYSCALL_DEFINE3</span><span class="p">(</span><span class="n">read</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="kt">int</span><span class="p">,</span> <span class="n">fd</span><span class="p">,</span> <span class="kt">char</span> <span class="n">__user</span> <span class="o">*</span><span class="p">,</span> <span class="n">buf</span><span class="p">,</span> <span class="kt">size_t</span><span class="p">,</span> <span class="n">count</span><span class="p">)</span>
</code></pre></div></div> <p>This doesn’t seem like an ordinary defination of a function, so what is <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE3</code> macro and how does the Linux Kernel turn the above definition into <code class="language-plaintext highlighter-rouge">__x64_sys_read</code> in the syscall table?</p> <p>If we go back to the definition of syscall table, we shall find that it is defined as an array of <code class="language-plaintext highlighter-rouge">sys_call_ptr_t</code>, which based on its name, we know it should be a function pointer pointing to syscall handler. It is defined in <code class="language-plaintext highlighter-rouge">/arch/x86/include/asm/syscall.h</code> as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">typedef</span> <span class="n">asmlinkage</span> <span class="nf">long</span> <span class="p">(</span><span class="o">*</span><span class="n">sys_call_ptr_t</span><span class="p">)(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="p">);</span>
</code></pre></div></div> <p>According to this definition, each syscall handler should take <code class="language-plaintext highlighter-rouge">const struct pt_regs *</code> – which saves the register context – as the single argument and return a long variable. But why didn’t we see <code class="language-plaintext highlighter-rouge">const struct pt_regs *</code> in the argument list of <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE3</code>? What steps are performed between the Kernel passes <code class="language-plaintext highlighter-rouge">struct pt_regs</code> to the syscall handler entry and the ultimate handler is invoked?</p> <p>Let’s begin with <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE&lt;n&gt;</code> macro in <code class="language-plaintext highlighter-rouge">/include/linux/syscalls.h</code>. The purpose of this macro is to define a format of syscall handler within the Kernel. As we mentioned in the previous article, the <code class="language-plaintext highlighter-rouge">&lt;n&gt;</code> here stands for the number of arguments that this syscall handler takes. Although there is no restriction on the number of arguments for a C function, a caller on the <code class="language-plaintext highlighter-rouge">x86_64</code> architecture can use at most 6 registers for argument passing to the callee, which are <code class="language-plaintext highlighter-rouge">%rdi, %rsi, %rdx, %rcx, %r8, %r9</code> in left-to-right order. Therefore, the <code class="language-plaintext highlighter-rouge">&lt;n&gt;</code> in <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE&lt;n&gt;</code> macro ranges from 0 to 6 on <code class="language-plaintext highlighter-rouge">x86_64</code>. Here is the definition of the series of <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE&lt;n&gt;</code> macro:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#define SYSCALL_DEFINE_MAXARGS	6
</span>
<span class="cp">#define SYSCALL_DEFINE1(name, ...) SYSCALL_DEFINEx(1, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE2(name, ...) SYSCALL_DEFINEx(2, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE3(name, ...) SYSCALL_DEFINEx(3, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE4(name, ...) SYSCALL_DEFINEx(4, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE5(name, ...) SYSCALL_DEFINEx(5, _##name, __VA_ARGS__)
#define SYSCALL_DEFINE6(name, ...) SYSCALL_DEFINEx(6, _##name, __VA_ARGS__)
</span>
<span class="cp">#define SYSCALL_DEFINEx(x, sname, ...)				\
	__SYSCALL_DEFINEx(x, sname, __VA_ARGS__)
</span></code></pre></div></div> <p>What worth noticing is the <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINE0</code> macro, which might be defined differently across hardware architecture. On <code class="language-plaintext highlighter-rouge">x86_64</code>, it is defined in <code class="language-plaintext highlighter-rouge">/arch/x86/include/asm/syscall_wrapper.h</code> as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * As the generic SYSCALL_DEFINE0() macro does not decode any parameters for
 * obvious reasons, and passing struct pt_regs *regs to it in %rdi does not
 * hurt, we only need to re-define it here to keep the naming congruent to
 * SYSCALL_DEFINEx()
 */</span>
<span class="cp">#ifndef SYSCALL_DEFINE0
#define SYSCALL_DEFINE0(sname)						\
	asmlinkage long __x64_sys_##sname(const struct pt_regs *__unused);\
	asmlinkage long __x64_sys_##sname(const struct pt_regs *__unused)
#endif
</span></code></pre></div></div> <p>Now we have reached the end of syscalls that takes no argument (e.g., <code class="language-plaintext highlighter-rouge">fork</code> and <code class="language-plaintext highlighter-rouge">getpid</code>). Let’s see how <code class="language-plaintext highlighter-rouge">SYSCALL_DEFINEx</code> helps to implement an uniform interface for various syscalls that may have different number of arguments. On <code class="language-plaintext highlighter-rouge">x86_64</code>, <code class="language-plaintext highlighter-rouge">__SYSCALL_DEFINEx</code> is defined in <code class="language-plaintext highlighter-rouge">/arch/x86/include/asm/syscall_wrapper.h</code> as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * Instead of the generic __SYSCALL_DEFINEx() definition, this macro takes
 * struct pt_regs *regs as the only argument of the syscall stub named
 * __x64_sys_*(). It decodes just the registers it needs and passes them on to
 * the __se_sys_*() wrapper performing sign extension and then to the
 * __do_sys_*() function doing the actual job. These wrappers and functions
 * are inlined (at least in very most cases), meaning that the assembly looks
 * as follows (slightly re-ordered for better readability):
 *
 * &lt;__x64_sys_recv&gt;:		&lt;-- syscall with 4 parameters
 *	callq	&lt;__fentry__&gt;
 *
 *	mov	0x70(%rdi),%rdi	&lt;-- decode regs-&gt;di
 *	mov	0x68(%rdi),%rsi	&lt;-- decode regs-&gt;si
 *	mov	0x60(%rdi),%rdx	&lt;-- decode regs-&gt;dx
 *	mov	0x38(%rdi),%rcx	&lt;-- decode regs-&gt;r10
 *
 *	xor	%r9d,%r9d	&lt;-- clear %r9
 *	xor	%r8d,%r8d	&lt;-- clear %r8
 *
 *	callq	__sys_recvfrom	&lt;-- do the actual work in __sys_recvfrom()
 *				    which takes 6 arguments
 *
 *	cltq			&lt;-- extend return value to 64-bit
 *	retq			&lt;-- return
 *
 * This approach avoids leaking random user-provided register content down
 * the call chain.
 */</span>
<span class="cp">#define __SYSCALL_DEFINEx(x, name, ...)					\
	asmlinkage long __x64_sys##name(const struct pt_regs *regs);	\
	static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__));	\
	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__));\
	asmlinkage long __x64_sys##name(const struct pt_regs *regs)	\
	{								\
		return __se_sys##name(SC_X86_64_REGS_TO_ARGS(x,__VA_ARGS__));\
	}								\
	static long __se_sys##name(__MAP(x,__SC_LONG,__VA_ARGS__))	\
	{								\
		long ret = __do_sys##name(__MAP(x,__SC_CAST,__VA_ARGS__));\
		__MAP(x,__SC_TEST,__VA_ARGS__);				\
		return ret;						\
	}								\
	static inline long __do_sys##name(__MAP(x,__SC_DECL,__VA_ARGS__))
</span></code></pre></div></div> <p>In short, this macro involves multiple declaration and definition to hide the process of extracting arguments from register context. But let’s start with the invocation chain first. Using <code class="language-plaintext highlighter-rouge">read</code> as an example, the invocation chain is <code class="language-plaintext highlighter-rouge">__x64_sys_read</code> -&gt; <code class="language-plaintext highlighter-rouge">__se_sys_read</code> -&gt; <code class="language-plaintext highlighter-rouge">__do_sys_read</code>. Therefore, the code for <code class="language-plaintext highlighter-rouge">read</code> is within a local function named <code class="language-plaintext highlighter-rouge">__do_sys_read</code>. Now we will move on to the more complicated process – the declaration and extraction of syscall arguments.</p> <h2 id="how-to-deal-with-different-number-of-arguments">How to deal with different number of arguments?</h2> <p>Let’s parse the above definition of <code class="language-plaintext highlighter-rouge">__SYSCALL_DEFINEx</code> into the three functions and go through them one by one.</p> <h3 id="extract-the-maximum-number-of-arguments-from-register-context">Extract the maximum number of arguments from register context</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">__x64_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__se_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="n">SC_X86_64_REGS_TO_ARGS</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">__VA_ARGS__</span><span class="p">));</span>
<span class="p">}</span>
</code></pre></div></div> <p>The first function <code class="language-plaintext highlighter-rouge">__x64_sys##name()</code> is the exposed syscall entry. The argument <code class="language-plaintext highlighter-rouge">struct pt_regs</code> is where values of all registers are saved and <code class="language-plaintext highlighter-rouge">x</code> is the number of arguments for this syscall. As we mentioned before, a syscall takes at most 6 arguments, passing via <code class="language-plaintext highlighter-rouge">%rdi, %rsi, %rdx, %rcx, %r8, %r9</code> in left-to-right order. Therefore, the first step is to extract these 6 arguments from the full register context to avoid any unnecessary exposure of register information. This is performed by the following<code class="language-plaintext highlighter-rouge">SC_X86_64_REGS_TO_ARGS</code> macro.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/* Mapping of registers to parameters for syscalls on x86-64 and x32 */</span>
<span class="cp">#define SC_X86_64_REGS_TO_ARGS(x, ...)					\
	__MAP(x,__SC_ARGS						\
		,,regs-&gt;di,,regs-&gt;si,,regs-&gt;dx				\
		,,regs-&gt;r10,,regs-&gt;r8,,regs-&gt;r9)			\
</span></code></pre></div></div> <p>The details of <code class="language-plaintext highlighter-rouge">__MAP</code> will be discussed later, but in short, this macro concatenate the variable and its type together in a certain format. Here is what we get after expanding <code class="language-plaintext highlighter-rouge">__MAP</code>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">asmlinkage</span> <span class="kt">long</span> <span class="n">__x64_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="k">const</span> <span class="k">struct</span> <span class="n">pt_regs</span> <span class="o">*</span><span class="n">regs</span><span class="p">)</span>
<span class="p">{</span>
	<span class="k">return</span> <span class="n">__se_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">di</span><span class="p">,</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">si</span><span class="p">,</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">dx</span><span class="p">,</span>
						<span class="n">regs</span><span class="o">-&gt;</span><span class="n">r10</span><span class="p">,</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r8</span><span class="p">,</span><span class="n">regs</span><span class="o">-&gt;</span><span class="n">r9</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="cast-the-register-content-into-the-required-type">Cast the register content into the required type</h3> <p>Now we move on to the second function <code class="language-plaintext highlighter-rouge">__se_sys##name()</code>.</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kt">long</span> <span class="n">__se_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="n">__MAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">__SC_LONG</span><span class="p">,</span><span class="n">__VA_ARGS__</span><span class="p">))</span>
<span class="p">{</span>
	<span class="kt">long</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">__do_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="n">__MAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">__SC_CAST</span><span class="p">,</span><span class="n">__VA_ARGS__</span><span class="p">));</span>
	<span class="n">__MAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">__SC_TEST</span><span class="p">,</span><span class="n">__VA_ARGS__</span><span class="p">);</span>
	<span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div> <h3 id="invocation-of-the-ultimate-syscall-handler">Invocation of the ultimate syscall handler</h3> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">static</span> <span class="kr">inline</span> <span class="kt">long</span> <span class="n">__do_sys</span><span class="err">##</span><span class="n">name</span><span class="p">(</span><span class="n">__MAP</span><span class="p">(</span><span class="n">x</span><span class="p">,</span><span class="n">__SC_DECL</span><span class="p">,</span><span class="n">__VA_ARGS__</span><span class="p">))</span>
</code></pre></div></div> <h3 id="definition-of-argument-lists-via-__map">Definition of argument lists via <code class="language-plaintext highlighter-rouge">__MAP</code> </h3> <p>Now let’s see how <code class="language-plaintext highlighter-rouge">__MAP</code> macro deals with handler arguments. The definition is within <code class="language-plaintext highlighter-rouge">/include/linux/syscalls.h</code> as follows:</p> <div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cm">/*
 * __MAP - apply a macro to syscall arguments
 * __MAP(n, m, t1, a1, t2, a2, ..., tn, an) will expand to
 *    m(t1, a1), m(t2, a2), ..., m(tn, an)
 * The first argument must be equal to the amount of type/name
 * pairs given.  Note that this list of pairs (i.e. the arguments
 * of __MAP starting at the third one) is in the same format as
 * for SYSCALL_DEFINE&lt;n&gt;/COMPAT_SYSCALL_DEFINE&lt;n&gt;
 */</span>
<span class="cp">#define __MAP0(m,...)
#define __MAP1(m,t,a,...) m(t,a)
#define __MAP2(m,t,a,...) m(t,a), __MAP1(m,__VA_ARGS__)
#define __MAP3(m,t,a,...) m(t,a), __MAP2(m,__VA_ARGS__)
#define __MAP4(m,t,a,...) m(t,a), __MAP3(m,__VA_ARGS__)
#define __MAP5(m,t,a,...) m(t,a), __MAP4(m,__VA_ARGS__)
#define __MAP6(m,t,a,...) m(t,a), __MAP5(m,__VA_ARGS__)
#define __MAP(n,...) __MAP##n(__VA_ARGS__)
</span>
<span class="cp">#define __SC_DECL(t, a)	t a
#define __TYPE_AS(t, v)	__same_type((__force t)0, v)
#define __TYPE_IS_L(t)	(__TYPE_AS(t, 0L))
#define __TYPE_IS_UL(t)	(__TYPE_AS(t, 0UL))
#define __TYPE_IS_LL(t) (__TYPE_AS(t, 0LL) || __TYPE_AS(t, 0ULL))
#define __SC_LONG(t, a) __typeof(__builtin_choose_expr(__TYPE_IS_LL(t), 0LL, 0L)) a
#define __SC_CAST(t, a)	(__force t) a
#define __SC_TYPE(t, a)	t
#define __SC_ARGS(t, a)	a
#define __SC_TEST(t, a) (void)BUILD_BUG_ON_ZERO(!__TYPE_IS_LL(t) &amp;&amp; sizeof(t) &gt; sizeof(long))
</span>
</code></pre></div></div> <p><code class="language-plaintext highlighter-rouge">__MAP&lt;n&gt;</code> series is a recursive definition.</p> </div> </article> <br> <hr> <br> <ul class="list-disc pl-8"></ul> <h2 class="text-3xl font-semibold mb-4 mt-12">Enjoy Reading This Article?</h2> <p class="mb-2">Here are some more articles you might like to read next:</p> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/linux-syscall-101/">Syscall 101: Introduction to System Calls</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/linux-syscall-201/">Syscall 201: The Lifecycle of System Calls in Operaing System</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/linux-irq-101/">Interrupt and Exception 101</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2021/distill/">a distill-style blog post</a> </li> <li class="my-2"> <a class="text-pink-700 underline font-semibold hover:text-pink-800" href="/blog/2024/linux-io-multiplex/">I/O Multiplexing 101</a> </li> </div> </div> <footer class="fixed-bottom" role="contentinfo"> <div class="container mt-0"> © Copyright 2024 Yihan Yang. Powered by <a href="https://jekyllrb.com/" target="_blank" rel="external nofollow noopener">Jekyll</a> with <a href="https://github.com/alshedivat/al-folio" rel="external nofollow noopener" target="_blank">al-folio</a> theme. Hosted by <a href="https://pages.github.com/" target="_blank" rel="external nofollow noopener">GitHub Pages</a>. Photos from <a href="https://unsplash.com" target="_blank" rel="external nofollow noopener">Unsplash</a>. </div> </footer> <script src="https://cdn.jsdelivr.net/npm/jquery@3.6.0/dist/jquery.min.js" integrity="sha256-/xUj+3OJU5yExlq6GSYGSHk7tPXikynS7ogEvDej/m4=" crossorigin="anonymous"></script> <script src="/assets/js/bootstrap.bundle.min.js"></script> <script src="https://cdn.jsdelivr.net/npm/mdbootstrap@4.20.0/js/mdb.min.js" integrity="sha256-NdbiivsvWt7VYCt6hYNT3h/th9vSTL4EDWeGs5SN3DA=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/masonry-layout@4.2.2/dist/masonry.pkgd.min.js" integrity="sha256-Nn1q/fx0H7SNLZMQ5Hw5JLaTRZp0yILA/FRexe19VdI=" crossorigin="anonymous"></script> <script defer src="https://cdn.jsdelivr.net/npm/imagesloaded@5.0.0/imagesloaded.pkgd.min.js" integrity="sha256-htrLFfZJ6v5udOG+3kNLINIKh2gvoKqwEhHYfTTMICc=" crossorigin="anonymous"></script> <script defer src="/assets/js/masonry.js" type="text/javascript"></script> <script defer src="https://cdn.jsdelivr.net/npm/medium-zoom@1.1.0/dist/medium-zoom.min.js" integrity="sha256-ZgMyDAIYDYGxbcpJcfUnYwNevG/xi9OHKaR/8GK+jWc=" crossorigin="anonymous"></script> <script defer src="/assets/js/zoom.js?85ddb88934d28b74e78031fd54cf8308"></script> <script src="/assets/js/no_defer.js?2930004b8d7fcd0a8e00fdcfc8fc9f24"></script> <script defer src="/assets/js/common.js?da39b660470d1ba6e6b8bf5f37070b6e"></script> <script defer src="/assets/js/copy_code.js?12775fdf7f95e901d7119054556e495f" type="text/javascript"></script> <script defer src="/assets/js/jupyter_new_tab.js?d9f17b6adc2311cbabd747f4538bb15f"></script> <script async src="https://d1bxh8uas1mnw7.cloudfront.net/assets/embed.js"></script> <script async src="https://badge.dimensions.ai/badge.js"></script> <script type="text/javascript">window.MathJax={tex:{tags:"ams"}};</script> <script defer type="text/javascript" id="MathJax-script" src="https://cdn.jsdelivr.net/npm/mathjax@3.2.0/es5/tex-mml-chtml.js"></script> <script defer src="https://cdnjs.cloudflare.com/polyfill/v3/polyfill.min.js?features=es6"></script> <script type="text/javascript">function progressBarSetup(){"max"in document.createElement("progress")?(initializeProgressElement(),$(document).on("scroll",function(){progressBar.attr({value:getCurrentScrollPosition()})}),$(window).on("resize",initializeProgressElement)):(resizeProgressBar(),$(document).on("scroll",resizeProgressBar),$(window).on("resize",resizeProgressBar))}function getCurrentScrollPosition(){return $(window).scrollTop()}function initializeProgressElement(){let e=$("#navbar").outerHeight(!0);$("body").css({"padding-top":e}),$("progress-container").css({"padding-top":e}),progressBar.css({top:e}),progressBar.attr({max:getDistanceToScroll(),value:getCurrentScrollPosition()})}function getDistanceToScroll(){return $(document).height()-$(window).height()}function resizeProgressBar(){progressBar.css({width:getWidthPercentage()+"%"})}function getWidthPercentage(){return getCurrentScrollPosition()/getDistanceToScroll()*100}const progressBar=$("#progress");window.onload=function(){setTimeout(progressBarSetup,50)};</script> </body> </html>